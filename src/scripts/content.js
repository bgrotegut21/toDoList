
import {removeItem, addBindings, removeBindings, setArray, setObject} from "./elementEvents.js"
import {send} from "./send.js"
import { getInitialElements, getUpdatedElements } from "./pageLayout.js";
import {createBoard, createAddBoard, createBoardEditor, createListEditor, createUpComingBoard, createTaskArrangement} from "./template.js";
import {applyTaskChanges, removeNavEmpties, addBoardTasks } from "./contentEffects.js";


import {removeBoardOverlay, addBoardOverlay, shadeButtonColor, setTaskDate} from "./uiEffects.js";
import {findBoardTextBox, getElementByBoardIndex, getObjectValue, changeValueToDate,createTaskTemplate, getUpComingTasks} from "./utilities.js";
import {renderTimeTasks} from "./times.js";
import isToday from 'date-fns/isToday'
import isThisWeek from 'date-fns/isThisWeek'

import { storage } from "./storage.js";
import {checkSpaces} from "./utilities.js";






import {assignTaskIndex, assignBoardElements} from "./assign.js";



const Content = () => {

    let staticListTasks = [];
    let changedListTasks = []; 


    let taskChanges = [];

    let upcomingTasks = []

    let deletedUpComingItems = [];

    let index;
    let currentIndex;
    let isUpComing = false;

    let canDisrupt = false
    let name;
    let dom = getInitialElements();

    const removeContentBindings = (bool) => {
        let elements = getUpdatedElements();
        removeBindings(elements.boarderButton, addBoardTasksClick,"click");
        removeBindings(elements.deleteBoard,deleteBoard, "click");
        removeBindings(elements.editBoard,editBoard,"click");
        removeBindings(elements.taskAdders, addListEditorClick, "click")

    }

     const addContentBindings = () => {
        let elements = getUpdatedElements();

        addBindings(elements.boarderButton, addBoardTasksClick,"click");
        addBindings(elements.deleteBoard,deleteBoard, "click");
        addBindings(elements.editBoard,editBoard,"click");

        addBindings(elements.taskAdders, addListEditorClick, "click");


        
    }


    const addListBindings = () => {
        let elements = getUpdatedElements();
        addBindings(elements.button, shadeButtonColorClick, "click")
        addBindings(elements.trashIt,deleteTask, "click");
        addBindings(elements.finished,addTaskClick, "click");
        addBindings(elements.edit, editTask, "click");
        addBindings(elements.circleIcon, crossOutTask, "click");
        addBindings(elements.exitEditor, exitListEditor, "click");

    }

    const addTaskBindings = () => {
        addListBindings();
        addContentBindings();
    }
    
    const removeTaskBindings = () => {
        removeListBindings();
        removeContentBindings();
    }



    const addChangeNameBinding = () => {
        let elements = getUpdatedElements();
        addBindings(elements.changeBoardTitleButtons, changeName, "click");
    }

    const removeListBindings = () => {
        let elements = getUpdatedElements();
        
        removeBindings(elements.changeBoardTitleButtons,changeName, "click");
        removeBindings(elements.button, shadeButtonColorClick, "click")
        removeBindings(elements.trashIt,deleteTask, "click");

        removeBindings(elements.finished,addTaskClick, "click");
        removeBindings(elements.edit, editTask, "click");
        removeBindings(elements.circleIcon, crossOutTask, "click");
        removeBindings(elements.exitEditor, exitListEditor, "click");
    }

    const crossOutDuplicateTask = (task) => {
        staticListTasks.forEach(board => {
            board.tasks.forEach(childTask => {
                if (childTask.navIndex == task.navIndex &&
                    childTask.navIndex != "upcoming"){
                    if(childTask.boardIndex == task.boardIndex){
                        if (childTask.taskIndex == task.taskIndex){
                           childTask.checked = task.checked;
                           removeCrossOutEditor(childTask);
                        }
                    }
                } else if (childTask.navIndex == "upcoming" &&
                          task.navIndex == "upcoming"
                ){
                    if (childTask.taskIndex == task.taskIndex){
                        childTask.checked = task.checked;
                        removeCrossOutEditor(childTask);
                    }
                }
            })
        })
    }



    const checkCrossOutEditor = (newTask) => {
        let boardCounter = 0;
        let canEdit = false;

        let taskIndex = newTask.taskIndex;
        let boardIndex = newTask.boardIndex;
        let navIndex = newTask.navIndex;


        staticListTasks.forEach(board => {
            let taskCounter = 0;
            board.changedBoardLists.forEach(task => {
            
                if (task.taskIndex == taskIndex &&
                    task.boardIndex == boardIndex && task.navIndex == navIndex
                    ){
                        let taskIndex =  taskCounter + 1;
                        let boardIndex = boardCounter;
                        if (taskIndex <= staticListTasks[boardIndex].changedBoardLists.length - 1){
                            let editor = staticListTasks[boardIndex].changedBoardLists[taskIndex];
                            if (editor.listEditor) canEdit = true;
                        }     
                    }
                    taskCounter ++;
            })
            boardCounter ++;
        })
        return canEdit;
    }



    const removeCrossOutEditor = (task) => {
        let indexes = getIndexes()
        if (indexes){
            if (checkCrossOutEditor(task)){
                removeListEditor();
            }
        }
    }


    const addListEditorToCrossOutTasks = () => {
        if (typeof index == "number"){
            let currentName = send.retrieveTitle(index);
            name = currentName;  
                      
            send.sendData(staticListTasks,index,name);  
            storage.storeData();


        } else if (index == "upcoming"){
            sendUpComingChanges();
        }
        renderBoardLists();
    }



    const crossOutTask= (event) => {

        let taskIndex = event.target.taskIndex;
        let boardIndex = event.target.boardIndex;

        let task = staticListTasks[boardIndex].tasks[taskIndex];
        task.checked ? task.checked = false: task.checked = true;
        let indexes = getIndexes();

       if (isUpComing) crossOutDuplicateTask(task);
       else {
           if(typeof indexes != "undefined"){
            let boardIndex2 = indexes.boardIndex;
            let listIndex = indexes.listIndex;
            if (boardIndex2 == boardIndex && listIndex == taskIndex){
                removeListEditor();
            }
           }

       }

       addListEditorToCrossOutTasks();
    }




     
    

    const deleteTask =  () => {
        let indexes = getIndexes();
        let taskIndex = indexes.listIndex;
        let boardIndex = indexes.boardIndex;
        let newStaticListTasks = setObject(staticListTasks);
        let deletedTask;
        let currentTask = newStaticListTasks[boardIndex].tasks[taskIndex];

        currentTask.listTask = false;
        deletedTask = currentTask;

        let newArray = newStaticListTasks[boardIndex].tasks;
        let newerArray = newArray.filter(task => task.listTask)

        deletedUpComingItems.push(deletedTask)
        staticListTasks[boardIndex].tasks = newerArray

        let newTasks =   staticListTasks[boardIndex].tasks
        staticListTasks[boardIndex].changedBoardLists = newTasks

        removeListEditor();
        if(isUpComing) removeUpComingTasks(deletedTask)
        activateContentMenu();
    }


    const removeUpComingTasks = (task) => {
        let newStaticListTasks = setObject(staticListTasks,true);


        let boardIndex = 0;
        let newTasks;

        newStaticListTasks.forEach(board => {
            newTasks = board.tasks.filter(childTask => {
                if (childTask.navIndex == "upcoming" && task.navIndex == "upcoming") {
                    if (childTask.taskIndex == task.taskIndex){
                        return false;
                    } else return true;

                } else  if (childTask.navIndex  ==  task.navIndex ) {
                    if (childTask.boardIndex == task.boardIndex &&
                        childTask.taskIndex == task.taskIndex
                        ){
                        return false;
                    } else return true;
                } else return true;

            })
            staticListTasks[boardIndex].tasks = newTasks
            staticListTasks[boardIndex].changedBoardLists = newTasks;
            boardIndex++;
        })
    }


    const editTask = (event) => {
        let boardIndex = event.target.boardIndex;
        let taskIndex = event.target.taskIndex;
        let task = staticListTasks[boardIndex].tasks[taskIndex];
        let text = task.text;
        let date = task.date;
        let priority = task.priority
        addListEditor(boardIndex, taskIndex, text, date,priority) 
    }

    const exitListEditor = () => {
        removeListEditor();
        renderBoardLists();
    }


    const removeListEditor = () => {
        staticListTasks.forEach(task => {
            let newTasks = task.changedBoardLists;
            newTasks = newTasks.filter(task => task.listEditor != true );
            task.changedBoardLists = newTasks;
        })

    }

    const findListEditorBoardIndex = () => {
        let newTasks = staticListTasks;
        let boardIndex = 0;
        let stopLoop = false;

        newTasks.forEach(board => {
            board.changedBoardLists.forEach(task => {
                if (task.listEditor == true){
                    stopLoop = true;
                    return
                }
            })
            if (stopLoop) return;
            boardIndex ++;
            
        })
        return boardIndex;
    }

    const getIndexes = () => {
        let breakLoop = false;
        let indexes;
        let boardIndex = 0;
        let listIndex;


        staticListTasks.forEach(task => {
            task.changedBoardLists.forEach(listTask => {
                if (listTask.listEditor){ 
                    if (typeof listTask.index != "undefined"){
                        listIndex = listTask.index;
                        indexes  = {boardIndex, listIndex};
                    }       
                    else indexes = false;
                    breakLoop = true;
                }
            })
            if (breakLoop) return;
            boardIndex ++;
        })
        return indexes;
    }

    const addTaskClick = () => {
        let indexes = getIndexes();

        if (indexes !== false){
            addTask(indexes.listIndex);
        } else {
            addTask();
        }
    }

    const changeDuplicateTasks = (navIndex,boardIndex,taskIndex, newTask) => {
        let currentBoardIndex =0;

        staticListTasks.forEach(board => {
            let currentTaskIndex = 0
            board.tasks.forEach(task => {
                if (task.navIndex == navIndex) {
                    if (task.boardIndex){
                        if (task.boardIndex == boardIndex){
                            if (task.taskIndex == taskIndex){
                                 staticListTasks[currentBoardIndex].tasks[currentTaskIndex] = newTask;
                                 let tasks = staticListTasks[currentBoardIndex].tasks;
                                 staticListTasks[currentBoardIndex].changedBoardLists = tasks;
                             }
                        }
                    } else {
                        if (task.taskIndex == taskIndex){
                             staticListTasks[currentBoardIndex].tasks[currentTaskIndex] = newTask;
                             let tasks = staticListTasks[currentBoardIndex].tasks;
                             staticListTasks[currentBoardIndex].changedBoardLists = tasks;
                         }   
                    }
                }
                currentTaskIndex ++
            })
            currentBoardIndex ++;
        })
    }


    const changeTask = (boardIndex, task, index) => {
        if (isUpComing){
            let oldTask =   staticListTasks[boardIndex].tasks[index];

            task.navName = oldTask.navName;
            task.taskIndex = oldTask.taskIndex;
            if (typeof oldTask.boardIndex != "undefined") task.boardIndex = oldTask.boardIndex;
            task.navIndex = oldTask.navIndex;
        }

        staticListTasks[boardIndex].tasks[index] = task;
        let tasks = staticListTasks[boardIndex].tasks;
        staticListTasks[boardIndex].changedBoardLists = tasks;



        if (isUpComing) changeDuplicateTasks(task.navIndex,task.boardIndex,task.taskIndex,task);

        if (isUpComing) addTaskToTime(task);
        if (isUpComing) removeOutOfDateTasks();
    }



    const createTask = (boardIndex,task) => {
        if (isUpComing){
            task.navIndex = "upcoming";
            task.navName = "Upcoming";
            upcomingTasks.push(task);
            task.taskIndex = upcomingTasks.length -1;
        }

         staticListTasks[boardIndex].tasks.push(task);
         let tasks = staticListTasks[boardIndex].tasks;
         staticListTasks[boardIndex].changedBoardLists = tasks; 
         if (isUpComing) addTaskToTime(task);
         if (isUpComing) removeOutOfDateTasks();


    }

// upcoming task array will always give a unique task index because it using the length of the upcoming task
// which is only chaged when we get new data. The new data will change the task index so that it is in order
// so it isn't just a random number and that is why upcoming works.

    const addTask =  (index) => {
        let elements = getUpdatedElements();
        let dateValue = elements.datePicker[0].value
        let currentDate;
    
        if (dateValue.length == 0) currentDate = new Date();
        else currentDate = changeValueToDate(dateValue);
        let taskText = elements.taskTextBox[0].value;
        if (taskText.length == 0 || !checkSpaces(taskText) ) taskText = "New Task";

        let priority = getObjectValue("listEditor","priority",staticListTasks);
        let task = createTaskTemplate(taskText,currentDate,priority);
        let boardIndex = findListEditorBoardIndex();
         typeof index != "undefined" ? changeTask(boardIndex, task,index): createTask(boardIndex,task)
       activateContentMenu();
    }


    const getNewIndexes = (newTask) => {
        let newBoardIndex;
        let breakLoop = false;
        let newTaskIndex;

        staticListTasks.forEach(board => {
            let currentTaskIndex = 0;
            board.tasks.forEach(task => {
                if (task.navIndex == "upcoming"){
                    if (task.taskIndex == newTask.taskIndex){
                        if (board.text == "Week") newBoardIndex = 0;
                        if (board.text == "Today") newBoardIndex = 1;
                        breakLoop = true
                        newTaskIndex = currentTaskIndex;
                        return;
                    }
                }
                currentTaskIndex ++;

            })
            if(breakLoop) return;
        })
        return {newBoardIndex, newTaskIndex};
    }


    const addTaskToTime = (newTask) => {
        let newIndex= getNewIndexes(newTask);
        if (typeof newIndex.newBoardIndex == "undefined") return;
       
        let newBoardIndex = newIndex.newBoardIndex;
        let newTaskIndex = newIndex.newTaskIndex;
        let addTask = false;
        
        let currentTask = staticListTasks[newBoardIndex].tasks[newTaskIndex];

        if (typeof currentTask != "undefined") {
            if (currentTask.taskIndex == newTask.taskIndex && currentTask.navIndex == "upcoming" && newTask.navIndex == "upcoming"){
                
            
                staticListTasks[newBoardIndex].tasks[newTaskIndex] = newTask;
                let tasks =  staticListTasks[newBoardIndex].tasks;
                staticListTasks[newBoardIndex].changedBoardLists = tasks;
            } else if (currentTask.navIndex == "upcoming" && newTask.navIndex == "upcoming"){
                addTask = true;
            }
        }

        if (typeof currentTask == "undefined" ||
            currentTask.navIndex != "upcoming" || addTask
        ) {
            if (!checkUpComingTask(newTask)){
                staticListTasks[newBoardIndex].tasks.push(newTask);
                let tasks =  staticListTasks[newBoardIndex].tasks;
                staticListTasks[newBoardIndex].changedBoardLists = tasks;
            }
        }
    }


    const checkUpComingTask = (newTask) => {
        let isTask = false;
        let counter = 0;
        staticListTasks.forEach(board => {
            board.tasks.forEach(task => {
                if (task.navIndex == "upcoming"){
                    if (task.taskIndex == newTask.taskIndex){
                        counter ++;
                    }
                    if (counter == 2) {
                        isTask = true;
                        return;
                    }
                }
            })
        })
        return isTask;
    }


    const removeOutOfDateTasks = () => {
        addOutOfDateTasksToDeletedUpcomingItems();
        let boardIndex = 0;
        let newStaticListTasks = setObject(staticListTasks, true);

        newStaticListTasks.forEach(board => {
            board.tasks.forEach(task => {
                let tasks = board.tasks;
                let newTasks = tasks.filter(newTask => newTask.date != task.date)
                if (boardIndex == 0){
                    if (!isToday(task.date)) {
                        tasks = newTasks;
                        if (task.navIndex != "upcoming")taskChanges.push(task);
                    }
                } else {
                    if  (!isThisWeek(task.date)){
                        tasks = newTasks;
                        if (task.navIndex != "upcoming")taskChanges.push(task);
                    }
                }
                newStaticListTasks[boardIndex].tasks = tasks;
                newStaticListTasks[boardIndex].changedBoardLists = tasks;
            })
            boardIndex ++;
        })
        staticListTasks = newStaticListTasks
    }


    const addOutOfDateTasksToDeletedUpcomingItems = () => {
        staticListTasks.forEach(board => {
            board.tasks.forEach(task => {
                if(task.navIndex == "upcoming")
                if (!isThisWeek(task.date)){
                    deletedUpComingItems.push(task);
                }
            })
        })
    }


    const shadeButtonByClass = (className,color) => {
        let elements = getUpdatedElements();
        let buttons = elements.button;
        let button = buttons.filter(button => button.getAttribute("class") == className)[0];
        let buttonParagraph = Array.from(button.children)[0];
        buttonParagraph.style.background = color;

    }

    const shadeButtonByPriority = (priority) => {
        if (priority == "High") shadeButtonByClass("button high","red");
        else if (priority == "Medium") shadeButtonByClass("button medium", "#ff9800");
        else if (priority == "Low") shadeButtonByClass("button low", "green");
    }

    const shadeButtonColorClick = (event) => {
        shadeButtonColor(event,staticListTasks)
    }

    const deleteBoard = (event) => {
        staticListTasks = removeItem(staticListTasks, event.target.boardIndex);
        changedListTasks = staticListTasks
        activateContentMenu();
    }

    const removeEditTitleMenu = () => {
        staticListTasks.forEach(task => {
            let newTasks = task.changedBoardLists;
            newTasks = newTasks.filter(list => list.editBoard != true);
            task.changedBoardLists = newTasks;
        })
        
    }

    const editBoard = (event) => {
        let index = event.target.boardIndex;
        removeEditTitleMenu();
        let changedBoardLists = staticListTasks[index].changedBoardLists    
        let currentText = getElementByBoardIndex(index,"exampleBoardText").textContent;


        let editBoardTemplate = {editBoard: true, text:currentText};
        let newArray = [];
        newArray.push(editBoardTemplate);
        let finalArray = newArray.concat(changedBoardLists);

        staticListTasks[index].changedBoardLists = finalArray;
        currentIndex = index;
        renderBoardLists(true);
        
    }

    const addListEditorClick = (event) => {
        let boardIndex = event.target.boardIndex;
        addListEditor(boardIndex)
    }


    const addListEditor = (boardIndex,index,text,date,priority) => {

        removeListEditor()
        let finalArray;
        let listEditorTemplate;
        let currentDate = new Date();
        
        if (typeof index != "undefined")  listEditorTemplate = {listEditor: true, text:text,date: date,
                                                                priority:priority, boardIndex:boardIndex, index: index};


        else listEditorTemplate = {listEditor: true, text:"",date:currentDate,
                                    priority: "High",boardIndex:boardIndex, creatingTask: true};


        if (typeof index != "undefined") {
            let newTasks = staticListTasks[boardIndex].changedBoardLists;
            newTasks.splice(index +1,0,listEditorTemplate);
            finalArray = newTasks
        } else {
            let listBoardArray = [listEditorTemplate];
            let newTasks = staticListTasks[boardIndex].changedBoardLists;
            finalArray = newTasks.concat(listBoardArray);
        }

        staticListTasks[boardIndex].changedBoardLists = finalArray;
        renderBoardLists();
    }


    const changeName = () => {
        let elements = getUpdatedElements();
        let boardText = elements.boardContentTextBox[0].value;
        if (boardText.length == 0 ){
            removeEditTitleMenu();
            renderBoardLists();
            return;
        }   
        let newTasks = staticListTasks[currentIndex].changedBoardLists;
        newTasks = newTasks.filter(task => task.editBoard != true)
        
        staticListTasks[currentIndex].changedBoardLists = newTasks;
        staticListTasks[currentIndex].text = boardText;
       activateContentMenu();
    }

    const renderEditBoardTextValues  = () => {
        let index = 0;
        staticListTasks.forEach(task => {
            task.changedBoardLists.forEach(list =>{
                if (list.editBoard){
                    let currentText = findBoardTextBox(index);
                    list.text = currentText;
                }

            })
            index++;
        })
    }

    const renderBoardLists = (isChangedName) => {
        removeListBindings();
        removeBoardOverlay();

        let indexesLength = staticListTasks.length;
        for (let i = 0; i < indexesLength; i++) {
            if (staticListTasks.length != 0)renderSingleBoardList(i);
        }
        if (!isChangedName)addListBindings();
        else addChangeNameBinding();
    }

    const renderSingleBoardList = (index) => {
        let taskList = getElementByBoardIndex(index, "taskLists");
        let addDate = false;
        let date;
        taskList.innerHTML = "";

        staticListTasks[index].changedBoardLists.forEach(task => {
            if (task.editBoard){
                let boardText = createBoardEditor(task);
                taskList.innerHTML += boardText;
                addBoardOverlay(index);
            } else if (task.listEditor){
                let listText= createListEditor(task);
                taskList.innerHTML += listText;

                shadeButtonByPriority(task.priority);
                date = task.date;
                addDate = true;


            } else if (task.listTask){
                let taskText = createTaskArrangement(task);
                taskList.innerHTML += taskText;
            }
        })
     
        if (addDate) setTaskDate(date);
        let taskListChildren = Array.from(taskList.children)
        let boardIndex = taskList.boardIndex;
        assignTaskIndex(taskListChildren,boardIndex);
    }

    const addBoardTasksClick = () => {
        addBoardTasks(staticListTasks);
        changedListTasks = setArray(staticListTasks);
        activateContentMenu();
        
    }

    const activateContentMenu = () => {
        activateContent(index,false,name);

    }


    const renderListTasks = (isEmpty) => {
        let dom = getInitialElements();
        renderEditBoardTextValues();
        removeContentBindings();
        removeListBindings(); 

        if (!isEmpty &&  !isUpComing){
            let newTasks = changedListTasks.filter(task => task.addBoard != true);
            changedListTasks = newTasks;
           changedListTasks.push({addBoard: true});
        }
                
        dom.pageContent.innerHTML = "";
        changedListTasks.forEach(task => {
            if (task.board){
                let board = createBoard(task);
                dom.pageContent.innerHTML += board
            } else if (task.addBoard){
                let addBoard = createAddBoard();
                dom.pageContent.innerHTML += addBoard;
            } else if (task.isUpComingBoard){
                let upComingBoard = createUpComingBoard(task);
                dom.pageContent.innerHTML += upComingBoard;
            }
        })       

        addContentBindings();
        assignBoardElements();
        renderBoardLists();
    }


    const setChangedToDoListsEmpty = () => {
        staticListTasks.forEach(task => {
            task.changedBoardLists = [];

        })
    }

    const setChangedToDoLists = () => {
        staticListTasks.forEach(task => {
            task.changedBoardLists =  task.tasks;
        })
    }

    const activateNavContent = () => {
        staticListTasks = [];
        let newTasks = send.retrieveData(index);
        if (!newTasks){
            send.sendData([],index,name)
            newTasks = send.retrieveData(index);
        }
        staticListTasks = newTasks;
        changedListTasks = setArray(staticListTasks)
        setChangedToDoLists();
    }

    const activateUpComingContent = () => {
        staticListTasks = [];
        staticListTasks = renderTimeTasks(staticListTasks);
        isUpComing = true;
        changedListTasks = setArray(staticListTasks)
        upcomingTasks = getUpComingTasks(staticListTasks);

      
    }

    const removeNavTasks = () => {
        staticListTasks.forEach(board => {
            let tasks = board.tasks.forEach(task => task.navIndex == "upcoming");
            board.tasks = tasks;
        })
    }


    const disruptContent = (objectIndex) => {
            if (isUpComing) removeNavTasks();
            else staticListTasks = [];
            index = null;
            if (objectIndex < 0) {
              if (!isUpComing) renderListTasks(true);
              canDisrupt = true;
            } 

        }

     
    const removeUpComingItems = (navs) => {
        deletedUpComingItems.forEach(task => {
            if (task.navIndex == "upcoming"){
                navs[task.navIndex][task.taskIndex] = "empty"

            } else {
                navs[task.navIndex][task.boardIndex].tasks[task.taskIndex] = "empty"
            }

        })
        navs = removeNavEmpties(navs);
        deletedUpComingItems = [];
        return navs;

    }

    const sendUpComingChanges = () => {
        let navs = send.getAllData();
        staticListTasks.forEach(board => {
            board.tasks.forEach(task => {
                let newTask = task;
                if (task.listTask){     
                    if (task.navIndex != "upcoming"){
                        let text = task.text;
                        let date = task.date;
                        let priority = task.priority;
                        let projectTypeText = task.projectTypeText;
                        let checked = task.checked;
                        newTask = createTaskTemplate(text, date, priority, projectTypeText, checked)
                    }        
                    if(task.navIndex == "upcoming") {
                        navs[task.navIndex][task.taskIndex] = newTask;
                    }
                    else navs[task.navIndex][task.boardIndex].tasks[task.taskIndex] = newTask;
                } 
            })
        })
        if(deletedUpComingItems.length != 0) navs = removeUpComingItems(navs);
        let newData = setObject(navs);
        newData = applyTaskChanges(newData,taskChanges);
        taskChanges = [];

        send.overwriteData(newData);
        storage.storeData();
    }

    const getIsUpComing  = () => {
        return isUpComing;
    }

    const getIndex = () => {
        return index;
    }


    const activateContent = (objectIndex, disruptFlow,objectName) => {
        changedListTasks = [];
        upcomingTasks = [];
        setChangedToDoListsEmpty();
     
        canDisrupt = false;
        if (disruptFlow) {
            disruptContent(objectIndex)
            if (canDisrupt) {
                if (isUpComing) activateContent("upcoming");
                return
            }
        }

        if (typeof index == "number"){
            let currentName = send.retrieveTitle(index);
            name = currentName;  
                      
            send.sendData(staticListTasks,index,name);  
            storage.storeData();


        } else if (index == "upcoming"){
            sendUpComingChanges();
        }

        isUpComing = false;

        index = objectIndex;
        name = objectName;

        if (index == "upcoming"){
            activateUpComingContent();
        } else {
            activateNavContent();


        }
        renderListTasks();
    }
    return {activateContent,removeTaskBindings, addTaskBindings, getIsUpComing,getIndex };
}

let contentMenu = Content();
export {contentMenu};   